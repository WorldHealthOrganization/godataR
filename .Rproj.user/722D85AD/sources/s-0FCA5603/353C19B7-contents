#' Download cases from Go.Data (version 2.38.1 or later)
#'
#' @param url Insert the base URL for your instance of Go.Data here. Don't forget the forward slash "/" at end!
#' @param username The email address for your Go.Data login.
#' @param password The password for your Go.Data login
#' @param outbreak_id The id number for the outbreak for which you want to download cases.
#' @param wait The number of seconds to wait in between iterations of checking the status of the download. Default is 5 seconds, but the user can specify a smaller value to speed up the process if the dataset is small.
#'
#' @return
#' Returns data frame of cases. Some fields, such as addresses, hospitalization history, and questionnaire fields will require further unnesting. See the tidyr::unnest() function.
#' @export
#' @examples
#' url <- "https://MyGoDataServer.com/"
#' username <- "myemail@email.com"
#' password <- "mypassword"
#' outbreak_id <- "3b5554d7-2c19-41d0-b9af-475ad25a382b"
#'
#' cases <- get_cases2(url=url, username=username, password=password, outbreak_id=outbreak_id)
#' @importFrom magrittr %>%
#' @import dplyr
#' @import tidyr
#' @import httr
#' @importFrom jsonlite fromJSON
#' @importFrom purrr pluck

get_cases2 <- function(url=url, username=username, password=password, outbreak_id=outbreak_id, wait=5) {

  #Check version of Go.Data
  if (check_godata_version(url=url)==FALSE) {
      stop("Go.Data must be version 2.38.1 or later. Please use the function get_cases() instead.")
  }

  #Check that outbreak_id is active
  if (outbreak_id != get_active_outbreak(url=url, username=username, password=password)) {
    set_active_outbreak(url=url, username=username, password=password, outbreak_id=outbreak_id)
  }

  #Submit an export request to the system
  request_id <- GET(paste0(url,"api/outbreaks/",outbreak_id,"/cases/export",
                               "?filter=%7B%22where%22%3A%7B%22useDbColumns%22%3A%22true%22%2C%20%22dontTranslateValues%22%3A%22true%22%2C%20%22jsonReplaceUndefinedWithNull%22%3A%22true%22%20%7D%7D",
                               "&access_token=",get_access_token(url=url, username=username, password=password))) %>%
      content() %>%
      pluck("exportLogId")

  #Check status of request periodcially, until finished
  #function argument 'wait' determines the number of seconds to wait between iterations
  export.request.status <- get_export_status(url=url, username=username, password=password, request_id=request_id)

  # export.request.status <- GET(paste0(url,"api/export-logs/",export.request.id,"?access_token=",get_access_token(url=url, username=username, password=password))) %>%
  #   content() %>%
  #   pluck("statusStep")
  while(export.request.status$statusStep != "LNG_STATUS_STEP_EXPORT_FINISHED") {
    Sys.sleep(wait)
    export.request.status <- GET(paste0(url,"api/export-logs/",export.request.id,"?access_token=",get_access_token(url=url, username=username, password=password))) %>%
      content() %>%
      pluck("statusStep")
    message(paste0("...processed ",export.request.status$processedNo, " of ", export.request.status$totalNo, " records"))
  }

  #Download the export
  message("...beginning download")
  df <- GET(paste0(url,"api/export-logs/",export.request.id,"/download?access_token=",get_access_token(url=url, username=username, password=password))) %>%
    content("text") %>%
    fromJSON(flatten=TRUE)
  message("...download complete!")

  # fix one strange variable name
  names(df)[names(df) %in% "_id"] <- "id"

  return(df)

}
